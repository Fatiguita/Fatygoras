import { AUTO_SAVE_TAG } from "../constants";

// --- IndexedDB Helper for Handles ---
const DB_NAME = 'FatygorasDB';
const STORE_NAME = 'settings';

const openDB = () => {
    return new Promise<IDBDatabase>((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);
        request.onupgradeneeded = (e: any) => {
            e.target.result.createObjectStore(STORE_NAME);
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
};

export const storeDirectoryHandle = async (handle: any) => {
    try {
        const db = await openDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readwrite');
            tx.objectStore(STORE_NAME).put(handle, 'autosave_handle');
            tx.oncomplete = () => resolve(true);
            tx.onerror = () => reject(tx.error);
        });
    } catch (e) {
        console.error("Failed to store handle in DB", e);
    }
};

export const getStoredDirectoryHandle = async () => {
    try {
        const db = await openDB();
        return new Promise<any>((resolve, reject) => {
            const tx = db.transaction(STORE_NAME, 'readonly');
            const req = tx.objectStore(STORE_NAME).get('autosave_handle');
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    } catch (e) {
        console.error("Failed to retrieve handle from DB", e);
        return null;
    }
};

// --- Script Generation ---

export const generateCleanupScript = () => {
    const script = `
const fs = require('fs');
const path = require('path');

// CONFIGURATION
// Use the current directory where this script runs as the target
const TARGET_DIR = __dirname;
const CRYPTO_TAG = '${AUTO_SAVE_TAG}';
const KEEP_COUNT = 2; // Keep last 2 instances

console.log(\`Starting Session Cleanup for tag: \${CRYPTO_TAG} in \${TARGET_DIR}\`);

try {
    const files = fs.readdirSync(TARGET_DIR);
    
    // Group files by Session Name
    // Expected format: Name_Date_CRYPTO_TAG.json
    const sessions = {};

    files.forEach(file => {
        if (!file.endsWith('.json') || !file.includes(CRYPTO_TAG)) return;

        // Simple parsing logic
        // Assuming: SessionName_YYYY-MM-DDTHH-mm-ss_FATY_V4_AUTO.json
        // We split by the crypto tag to isolate the unique name+date part
        const parts = file.split('_' + CRYPTO_TAG);
        if (parts.length < 1) return;

        // To group effectively, we need the "Base Name" (Session Name).
        // This is tricky if the session name has underscores.
        // Strategy: Use the Date regex to find the split point.
        // ISO Date usually contains colons or dashes. 
        // Our App saves as: Name_Timestamp_Tag.json
        
        // Let's rely on the file stats for sorting, grouping by name is the challenge.
        // Let's assume the name is everything before the last 2 underscores if we use a strict format.
        // Format: Name_TIMESTAMP_TAG.json
        
        const nameParts = file.replace('.json', '').split('_');
        // Remove Tag
        nameParts.pop(); // Remove Tag
        const timestamp = nameParts.pop(); // Remove Timestamp
        const sessionName = nameParts.join('_'); // Reconstruct Name

        if (!sessions[sessionName]) {
            sessions[sessionName] = [];
        }
        
        sessions[sessionName].push({
            filename: file,
            time: parseInt(timestamp) || 0
        });
    });

    // Process Deletion
    Object.keys(sessions).forEach(name => {
        const filesList = sessions[name];
        
        // Sort descending by time (newest first)
        filesList.sort((a, b) => b.time - a.time);

        if (filesList.length > KEEP_COUNT) {
            console.log(\`Cleaning session: \${name} (Found \${filesList.length}, keeping \${KEEP_COUNT})\`);
            
            // Files to delete
            const toDelete = filesList.slice(KEEP_COUNT);
            
            toDelete.forEach(f => {
                const fullPath = path.join(TARGET_DIR, f.filename);
                try {
                    fs.unlinkSync(fullPath);
                    console.log(\`  Deleted: \${f.filename}\`);
                } catch (err) {
                    console.error(\`  Error deleting \${f.filename}: \${err.message}\`);
                }
            });
        }
    });

    console.log("Cleanup Complete.");

} catch (err) {
    console.error("Critical Error:", err);
}

// Keep terminal open briefly
setTimeout(() => {}, 2000);
`;

    return script;
};

export const generateCleanupReadme = () => {
    return `# Fatygoras Auto-Save Cleanup Script

This script automatically cleans up old session files generated by Fatygoras Auto-Save.
It keeps the last 2 instances of every unique session and deletes older ones to save space.

## Prerequisites
1. You must have **Node.js** installed on your system.
   - Download: https://nodejs.org/

## Setup
1. Place the \`cleanup_sessions.js\` file inside the folder where you are Auto-Saving your sessions.

## Usage

### Windows (Easy)
1. Create a file named \`run_cleanup.bat\` in the same folder.
2. Edit it and paste the following code:
   \`\`\`batch
   @echo off
   node cleanup_sessions.js
   timeout /t 5
   \`\`\`
3. Double click \`run_cleanup.bat\` to run.
4. **To run on boot**: Press \`Win + R\`, type \`shell:startup\`, and paste a **Shortcut** to this .bat file inside that folder.

### Windows (Manual)
1. Right-click the folder and "Open Terminal".
2. Type: \`node cleanup_sessions.js\`

### Mac / Linux
1. Open Terminal.
2. Navigate to the folder: \`cd /path/to/your/save/folder\`
3. Run: \`node cleanup_sessions.js\`
4. **To run automatically:** Add a cron job (\`crontab -e\`) to run this script periodically.
   Example: \`*/10 * * * * /usr/bin/node /path/to/cleanup_sessions.js\` (Runs every 10 mins).
`;
};

export const saveToDirectory = async (
    dirHandle: any, // Using any to bypass strict TS check for non-standard API
    filename: string,
    content: string
) => {
    try {
        const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        return true;
    } catch (error) {
        console.error("Auto-save write error:", error);
        throw error;
    }
};